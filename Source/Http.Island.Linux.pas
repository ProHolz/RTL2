namespace RemObjects.Elements.RTL;

{$IF ISLAND AND LINUX}

{$GLOBALS ON}

interface

type
  CURLCode = public enum (
    CURLE_OK = 0, CURLE_UNSUPPORTED_PROTOCOL, CURLE_FAILED_INIT, CURLE_URL_MALFORMAT, CURLE_NOT_BUILT_IN,
    CURLE_COULDNT_RESOLVE_PROXY, CURLE_COULDNT_RESOLVE_HOST, CURLE_COULDNT_CONNECT, CURLE_FTP_WEIRD_SERVER_REPLY,
    CURLE_REMOTE_ACCESS_DENIED, CURLE_FTP_ACCEPT_FAILED, CURLE_FTP_WEIRD_PASS_REPLY, CURLE_FTP_ACCEPT_TIMEOUT,
    CURLE_FTP_WEIRD_PASV_REPLY, CURLE_FTP_WEIRD_227_FORMAT, CURLE_FTP_CANT_GET_HOST, CURLE_HTTP2,
    CURLE_FTP_COULDNT_SET_TYPE, CURLE_PARTIAL_FILE, CURLE_FTP_COULDNT_RETR_FILE, CURLE_OBSOLETE20, CURLE_QUOTE_ERROR,
    CURLE_HTTP_RETURNED_ERROR, CURLE_WRITE_ERROR, CURLE_OBSOLETE24, CURLE_UPLOAD_FAILED, CURLE_READ_ERROR, CURLE_OUT_OF_MEMORY,
    CURLE_OPERATION_TIMEDOUT, CURLE_OBSOLETE29, CURLE_FTP_PORT_FAILED, CURLE_FTP_COULDNT_USE_REST, CURLE_OBSOLETE32,
    CURLE_RANGE_ERROR, CURLE_HTTP_POST_ERROR, CURLE_SSL_CONNECT_ERROR, CURLE_BAD_DOWNLOAD_RESUME, CURLE_FILE_COULDNT_READ_FILE,
    CURLE_LDAP_CANNOT_BIND, CURLE_LDAP_SEARCH_FAILED, CURLE_OBSOLETE40, CURLE_FUNCTION_NOT_FOUND, CURLE_ABORTED_BY_CALLBACK,
    CURLE_BAD_FUNCTION_ARGUMENT, CURLE_OBSOLETE44, CURLE_INTERFACE_FAILED, CURLE_OBSOLETE46, CURLE_TOO_MANY_REDIRECTS,
    CURLE_UNKNOWN_OPTION, CURLE_TELNET_OPTION_SYNTAX, CURLE_OBSOLETE50, CURLE_PEER_FAILED_VERIFICATION, CURLE_GOT_NOTHING,
    CURLE_SSL_ENGINE_NOTFOUND, CURLE_SSL_ENGINE_SETFAILED, CURLE_SEND_ERROR, CURLE_RECV_ERROR, CURLE_OBSOLETE57,
    CURLE_SSL_CERTPROBLEM, CURLE_SSL_CIPHER, CURLE_SSL_CACERT, CURLE_BAD_CONTENT_ENCODING, CURLE_LDAP_INVALID_URL,
    CURLE_FILESIZE_EXCEEDED, CURLE_USE_SSL_FAILED, CURLE_SEND_FAIL_REWIND, CURLE_SSL_ENGINE_INITFAILED, CURLE_LOGIN_DENIED,
    CURLE_TFTP_NOTFOUND, CURLE_TFTP_PERM, CURLE_REMOTE_DISK_FULL, CURLE_TFTP_ILLEGAL, CURLE_TFTP_UNKNOWNID,
    CURLE_REMOTE_FILE_EXISTS, CURLE_TFTP_NOSUCHUSER, CURLE_CONV_FAILED, CURLE_CONV_REQD, CURLE_SSL_CACERT_BADFILE,
    CURLE_REMOTE_FILE_NOT_FOUND, CURLE_SSH, CURLE_SSL_SHUTDOWN_FAILED, CURLE_AGAIN, CURLE_SSL_CRL_BADFILE, CURLE_SSL_ISSUER_ERROR,
    CURLE_FTP_PRET_FAILED, CURLE_RTSP_CSEQ_ERROR, CURLE_RTSP_SESSION_ERROR, CURLE_FTP_BAD_FILE_LIST, CURLE_CHUNK_FAILED,
    CURLE_NO_CONNECTION_AVAILABLE, CURLE_SSL_PINNEDPUBKEYNOTMATCH, CURLE_SSL_INVALIDCERTSTATUS, CURL_LAST
  );

  const
    CURLINFO_STRING   = $100000;
    CURLINFO_LONG     = $200000;
    CURLINFO_DOUBLE   = $300000;
    CURLINFO_SLIST    = $400000;
    CURLINFO_SOCKET   = $500000;
    CURLINFO_MASK     = $0fffff;
    CURLINFO_TYPEMASK = $f00000;

  type
  CURLINFO = public enum(
    CURLINFO_NONE,
    CURLINFO_EFFECTIVE_URL    = CURLINFO_STRING + 1,
    CURLINFO_RESPONSE_CODE    = CURLINFO_LONG   + 2,
    CURLINFO_TOTAL_TIME       = CURLINFO_DOUBLE + 3,
    CURLINFO_NAMELOOKUP_TIME  = CURLINFO_DOUBLE + 4,
    CURLINFO_CONNECT_TIME     = CURLINFO_DOUBLE + 5,
    CURLINFO_PRETRANSFER_TIME = CURLINFO_DOUBLE + 6,
    CURLINFO_SIZE_UPLOAD      = CURLINFO_DOUBLE + 7,
    CURLINFO_SIZE_DOWNLOAD    = CURLINFO_DOUBLE + 8,
    CURLINFO_SPEED_DOWNLOAD   = CURLINFO_DOUBLE + 9,
    CURLINFO_SPEED_UPLOAD     = CURLINFO_DOUBLE + 10,
    CURLINFO_HEADER_SIZE      = CURLINFO_LONG   + 11,
    CURLINFO_REQUEST_SIZE     = CURLINFO_LONG   + 12,
    CURLINFO_SSL_VERIFYRESULT = CURLINFO_LONG   + 13,
    CURLINFO_FILETIME         = CURLINFO_LONG   + 14,
    CURLINFO_CONTENT_LENGTH_DOWNLOAD = CURLINFO_DOUBLE + 15,
    CURLINFO_CONTENT_LENGTH_UPLOAD   = CURLINFO_DOUBLE + 16,
    CURLINFO_STARTTRANSFER_TIME = CURLINFO_DOUBLE + 17,
    CURLINFO_CONTENT_TYPE     = CURLINFO_STRING + 18,
    CURLINFO_REDIRECT_TIME    = CURLINFO_DOUBLE + 19,
    CURLINFO_REDIRECT_COUNT   = CURLINFO_LONG   + 20,
    CURLINFO_PRIVATE          = CURLINFO_STRING + 21,
    CURLINFO_HTTP_CONNECTCODE = CURLINFO_LONG   + 22,
    CURLINFO_HTTPAUTH_AVAIL   = CURLINFO_LONG   + 23,
    CURLINFO_PROXYAUTH_AVAIL  = CURLINFO_LONG   + 24,
    CURLINFO_OS_ERRNO         = CURLINFO_LONG   + 25,
    CURLINFO_NUM_CONNECTS     = CURLINFO_LONG   + 26,
    CURLINFO_SSL_ENGINES      = CURLINFO_SLIST  + 27,
    CURLINFO_COOKIELIST       = CURLINFO_SLIST  + 28,
    CURLINFO_LASTSOCKET       = CURLINFO_LONG   + 29,
    CURLINFO_FTP_ENTRY_PATH   = CURLINFO_STRING + 30,
    CURLINFO_REDIRECT_URL     = CURLINFO_STRING + 31,
    CURLINFO_PRIMARY_IP       = CURLINFO_STRING + 32,
    CURLINFO_APPCONNECT_TIME  = CURLINFO_DOUBLE + 33,
    CURLINFO_CERTINFO         = CURLINFO_SLIST  + 34,
    CURLINFO_CONDITION_UNMET  = CURLINFO_LONG   + 35,
    CURLINFO_RTSP_SESSION_ID  = CURLINFO_STRING + 36,
    CURLINFO_RTSP_CLIENT_CSEQ = CURLINFO_LONG   + 37,
    CURLINFO_RTSP_SERVER_CSEQ = CURLINFO_LONG   + 38,
    CURLINFO_RTSP_CSEQ_RECV   = CURLINFO_LONG   + 39,
    CURLINFO_PRIMARY_PORT     = CURLINFO_LONG   + 40,
    CURLINFO_LOCAL_IP         = CURLINFO_STRING + 41,
    CURLINFO_LOCAL_PORT       = CURLINFO_LONG   + 42,
    CURLINFO_TLS_SESSION      = CURLINFO_SLIST  + 43,
    CURLINFO_ACTIVESOCKET     = CURLINFO_SOCKET + 44,
    CURLINFO_LASTONE          = 44
  );

  curl_slist = public record
    data: ^AnsiChar;
    next: ^curl_slist;
  end;

  PCURL = ^void;
  CurlGlobalInitFunc = ^function(flags: Integer): CURLCode;
  CurlGlobalCleanupFunc = ^procedure;
  CurlEasyPerform = ^function(curl: PCURL): CURLCode;
  CurlEasyGetInfo1Func = ^function(curl: PCURL; info: CURLINFO; data: ^NativeInt): CURLCode;
  //function curl_easy_setopt(curl: PCURL; option: CURLoption): CURLcode; varargs; cdecl;
  CurlEasyInitFunc = ^function: PCURL;
  CurlEasyCleanUp = ^procedure(curl: PCURL);
  CurlSListAppendFunc = ^function(list: ^curl_slist; str: ^AnsiChar): ^curl_slist;
  CurlSListFreeAllFunc = ^procedure(list: ^curl_slist);

  CurlHelper = public class
  private
    class const LibCurl = 'libcurl.so';
    class var fLib: ^Void;
    class method GetSymbol(SymbolName: String): ^Void; inline;
  public
    class var GlobalInit: CurlGlobalInitFunc;
    class var GlobalCleanup: CurlGlobalCleanupFunc;
    class var EasyPerform: CurlEasyPerform;
    class var EasyGetInfo1: CurlEasyGetInfo1Func;
    class var EasyInit: CurlEasyInitFunc;
    class var EasyCleanUp: CurlEasyCleanUp;
    class var SListAppend: CurlSListAppendFunc;
    class var SListFreeAll: CurlSListFreeAllFunc;
    class constructor;
    finalizer;
  end;

implementation

class method CurlHelper.GetSymbol(SymbolName: String): ^Void;
begin
  result := rtl.dlsym(fLib, RemObjects.Elements.System.String(SymbolName).ToAnsiChars);
end;

class constructor CurlHelper;
begin
  fLib := rtl.dlopen(LibCurl.ToAnsiChars, rtl.RTLD_LAZY);

  GlobalInit := CurlGlobalInitFunc(GetSymbol('curl_global_init'));
  GlobalCleanup := CurlGlobalCleanupFunc(GetSymbol('curl_global_cleanup'));
  EasyPerform := CurlEasyPerform(GetSymbol('curl_easy_perform'));
  EasyGetInfo1 := CurlEasyGetInfo1Func(GetSymbol('curl_easy_getinfo'));
  EasyInit := CurlEasyInitFunc(GetSymbol('curl_easy_init'));
  EasyCleanUp := CurlEasyCleanUp(GetSymbol('curl_easy_cleanup'));
  SListAppend := CurlSListAppendFunc(GetSymbol('curl_slist_append'));
  SListFreeAll := CurlSListFreeAllFunc(GetSymbol('curl_slist_free_all'));

  GlobalInit^;
end;

finalizer CurlHelper;
begin
  GlobalCleanup^;
  rtl.dlclose(fLib);
end;
{$ENDIF}

end.